from flask import Blueprint, jsonify, request, Response
from datetime import datetime
import os
import zipfile
import re

api_bp = Blueprint('api', __name__)

@api_bp.route('/')
def api_home():
    """API home endpoint"""
    return jsonify({
        'message': 'Welcome to the API',
        'version': '1.0.0',
        'timestamp': datetime.utcnow().isoformat()
    })

@api_bp.route('/users', methods=['GET'])
def get_users():
    """Get all users"""
    # Example data - replace with actual database query
    users = [
        {'id': 1, 'name': 'John Doe', 'email': 'john@example.com'},
        {'id': 2, 'name': 'Jane Smith', 'email': 'jane@example.com'}
    ]
    return jsonify({'users': users})

@api_bp.route('/users', methods=['POST'])
def create_user():
    """Create a new user"""
    data = request.get_json()
    
    if not data or 'name' not in data or 'email' not in data:
        return jsonify({'error': 'Name and email are required'}), 400
    
    # Example validation and creation logic
    new_user = {
        'id': 3,  # In real app, this would be generated by database
        'name': data['name'],
        'email': data['email'],
        'created_at': datetime.utcnow().isoformat()
    }
    
    return jsonify({'user': new_user}), 201

@api_bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """Get a specific user by ID"""
    # Example data - replace with actual database query
    if user_id == 1:
        user = {'id': 1, 'name': 'John Doe', 'email': 'john@example.com'}
        return jsonify({'user': user})
    else:
        return jsonify({'error': 'User not found'}), 404

@api_bp.route('/users/<int:user_id>', methods=['PUT'])
def update_user(user_id):
    """Update a specific user"""
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'No data provided'}), 400
    
    # Example update logic
    updated_user = {
        'id': user_id,
        'name': data.get('name', 'Updated Name'),
        'email': data.get('email', 'updated@example.com'),
        'updated_at': datetime.utcnow().isoformat()
    }
    
    return jsonify({'user': updated_user})

@api_bp.route('/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    """Delete a specific user"""
    # Example deletion logic
    return jsonify({'message': f'User {user_id} deleted successfully'}), 200

@api_bp.route('/library', methods=['GET'])
def get_library():
    """Get the library"""
    manga_path = os.environ.get('MANGA_PATH')
    if not manga_path or not os.path.isdir(manga_path):
        return jsonify({'error': 'MANGA_PATH is not set or not a valid directory'}), 400

    subdirs = [name for name in os.listdir(manga_path) if os.path.isdir(os.path.join(manga_path, name))]

    return jsonify({'library': subdirs}), 200

@api_bp.route('/chapters/<string:manga_id>', methods=['GET'])
def get_chapters(manga_id):
    """Get a specific manga's chapters"""
    manga_path = os.path.join(os.environ.get('MANGA_PATH'), manga_id)
    if not os.path.isdir(manga_path):
        return jsonify({'error': 'Manga not found'}), 404

    chapter_files = sorted([name for name in os.listdir(manga_path) if name.endswith('.cbz')])
    chapters = []
    for chapter_file in chapter_files:
        volume_match = re.search(r'v(\d+)', chapter_file)
        chapter_match = re.search(r'c(\d+(?:\.\d+)?)', chapter_file)
        
        volume = None
        if volume_match:
            volume = int(volume_match.group(1))
        
        chapter = None
        if chapter_match:
            chapter_str = chapter_match.group(1)
            chapter_num = float(chapter_str)
            chapter = str(int(chapter_num)) if chapter_num.is_integer() else str(chapter_num)
        
        chapters.append({
            'chapter': chapter,
            'volume': volume
        })

    return jsonify({'chapters': chapters}), 200

@api_bp.route('/page/<string:manga_id>/<int:chapter_id>/<int:page_number>', methods=['GET'])
def get_page(manga_id, chapter_id, page_number):
    """Get a specific page from a CBZ chapter file"""
    manga_path = os.path.join(os.environ.get('MANGA_PATH'), manga_id)
    if not os.path.isdir(manga_path):
        return jsonify({'error': 'Manga not found'}), 404

    chapters = sorted([name for name in os.listdir(manga_path) if name.endswith('.cbz')])
    
    if chapter_id < 0 or chapter_id >= len(chapters):
        return jsonify({'error': 'Chapter not found'}), 404
    
    chapter_file = chapters[chapter_id]
    chapter_path = os.path.join(manga_path, chapter_file)
    
    try:
        with zipfile.ZipFile(chapter_path, 'r') as cbz_file:
            file_list = sorted(cbz_file.namelist())
            image_files = [f for f in file_list if f.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'))]
            if page_number < 0 or page_number >= len(image_files):
                return jsonify({'error': 'Page not found'}), 404
            
            image_file = image_files[page_number]
            image_data = cbz_file.read(image_file)
            file_ext = image_file.lower().split('.')[-1]
            content_type_map = {
                'jpg': 'image/jpeg',
                'jpeg': 'image/jpeg',
                'png': 'image/png',
                'gif': 'image/gif',
                'bmp': 'image/bmp',
                'webp': 'image/webp'
            }
            content_type = content_type_map.get(file_ext, 'image/jpeg')
            return Response(image_data, mimetype=content_type)
            
    except zipfile.BadZipFile:
        return jsonify({'error': 'Invalid CBZ file'}), 400
    except Exception as e:
        return jsonify({'error': f'Error reading CBZ file: {str(e)}'}), 500
